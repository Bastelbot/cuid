# CUID [![Build Status](https://secure.travis-ci.org/dilvie/cuid.png)](http://travis-ci.org/dilvie/cuid)

Collission-resistant ids optimized for horizontal scaling and sequential lookup performance.

For node and browsers.

.cuid() returns a short random string with some collision-busting measures. Safe to use as HTML element ID's, and unique server-side record lookups.

## Example

ch72gsb320000udocl363eofy

### Broken down


** c - h72gsb32 - 0000 - udoc - l363eofy **

The groups, in order, are:

* 'c' - identifies this as a cuid, and allows you to use it in html entity ids. The fixed value helps keep the ids sequential.
* timestamp
* counter - a single process might generate the same random string. The weaker the pseudo-random source, the higher the probability. That problem gets worse as processors get faster. The counter will roll over if the value gets too big.
* Client fingerprint
* Math.random()


## Motivation

Modern web applications have different requirements than applications from just a few years ago. Today, applications might need to support online / offline capability, which means we need a way for clients on different hosts to generate ids that won't collide with ids generated by other hosts -- even if they're not connected to the network.

Because entities might need to be generated in high-performance loops, id generation should be fast. That means no waiting around for asynchronous entropy pool requests, or cross-process/cross-network communication.

On the server-side, applications with millions of users usually need to scale horizontally. It's not uncommon to see pseudo-random uuid and guid algorithms start to collide more frequently when multiple hosts are handling multiple requests in the same millisecond timeframe, using the same pseudo-random generator technology.

Another common concern with uids and guids is that many of them are not sequential. Sequential ids can provide a performance optimization for data reads, because you frequently query the most recently created data first in a typical web application.


## Fingerprints

**In browsers**, the first chars are obtained from the user agent string (which is fairly unique), and the supported mimeTypes (which is also fairly unique, except for IE, which always returns 0).
That string is concatenated with a count of variables in the global scope (which is also fairly unique), and the result is trimmed to 4 chars.

**In node**, the first two chars are extracted from the process.pid. The next two chars are extracted from the hostname.
