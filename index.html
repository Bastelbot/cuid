<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Cuid : Collision-resistant ids optimized for horizontal scaling and performance.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Cuid</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ericelliott/cuid">View on GitHub</a>

          <h1 id="project_title">Cuid</h1>
          <h2 id="project_tagline">Collision-resistant ids optimized for horizontal scaling and performance.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/ericelliott/cuid/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/ericelliott/cuid/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="cuid" class="anchor" href="#cuid" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>cuid</h1>

<p><a href="https://travis-ci.org/ericelliott/cuid"><img src="https://travis-ci.org/ericelliott/cuid.svg" alt="Travis-CI"></a><a href="https://gitter.im/learn-javascript-courses/javascript-questions?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Gitter"></a></p>

<p>Collision-resistant ids optimized for horizontal scaling and binary search lookup performance.</p>

<p>Currently available for Node, browsers, Ruby, .Net, Go, PHP and Elixir (see ports below -- more ports are welcome).</p>

<p><code>cuid()</code> returns a short random string with some collision-busting measures. Safe to use as HTML element ID's, and unique server-side record lookups.</p>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h2>

<p>Node style. For the browser, either bundle with something like <a href="https://github.com/substack/node-browserify">browserify</a> or <a href="http://webpack.github.io/">webpack</a>, or use the stand-alone version and leave off the require line.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> cuid <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>cuid<span class="pl-pds">'</span></span>);
<span class="pl-en">console</span>.<span class="pl-c1">log</span>( <span class="pl-en">cuid</span>() );

<span class="pl-c">// ch72gsb320000udocl363eofy</span></pre></div>

<h2>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing</h2>

<pre><code>$ npm install --save cuid
</code></pre>

<p>or download the stand-alone version from <a href="https://github.com/ericelliott/cuid/tree/master/dist"><code>./dist</code></a>.</p>

<h3>
<a id="broken-down" class="anchor" href="#broken-down" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Broken down</h3>

<p>** c - h72gsb32 - 0000 - udoc - l363eofy **</p>

<p>The groups, in order, are:</p>

<ul>
<li>'c' - identifies this as a cuid, and allows you to use it in html entity ids.</li>
<li>Timestamp</li>
<li>Counter - a single process might generate the same random string. The weaker the pseudo-random source, the higher the probability. That problem gets worse as processors get faster. The counter will roll over if the value gets too big.</li>
<li>Client fingerprint</li>
<li>Pseudo random (<code>Math.random()</code> in JavaScript)</li>
</ul>

<h2>
<a id="fingerprints" class="anchor" href="#fingerprints" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fingerprints</h2>

<p><strong>In browsers</strong>, the first chars are obtained from the user agent string (which is fairly unique), and the supported mimeTypes (which is also fairly unique, except for IE, which always returns 0).
That string is concatenated with a count of variables in the global scope (which is also fairly unique), and the result is trimmed to 4 chars.</p>

<p><strong>In node</strong>, the first two chars are extracted from the process.pid. The next two chars are extracted from the hostname.</p>

<h2>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Motivation</h2>

<p>Modern web applications have different requirements than applications from just a few years ago. Our modern unique identifiers have a stricter list of requirements that cannot all be satisfied by any existing version of the GUID/UUID specifications:</p>

<h3>
<a id="horizontal-scalability" class="anchor" href="#horizontal-scalability" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Horizontal scalability</h3>

<p>Today's applications don't run on any single machine.</p>

<p>Applications might need to support online / offline capability, which means we need a way for clients on different hosts to generate ids that won't collide with ids generated by other hosts -- even if they're not connected to the network.</p>

<p>Most pseudo-random algorithms use time in ms as a random seed. Random IDs lack sufficient entropy when running in separate processes (such as cloned virtual machines or client browsers) to guarantee against collisions. Application developers report v4 UUID collisions causing problems in their applications when the ID generation is distributed between lots of machines such that lots of IDs are generated in the same millisecond.</p>

<p>Each new client exponentially increases the chance of collision in the same way that each new character in a random string exponentially reduces the chance of collision. Successful apps scale at hundreds or thousands of new clients per day, so fighting the lack of entropy by adding random characters is a losing strategy.</p>

<p>Because of the nature of this problem, it's possible to build an app from the ground up and scale it to a million users before this problem rears its head. By the time you notice the problem (when your peak hour use requires dozens of ids to be created per ms), if your db doesn't have unique constraints on the id because you thought your guids were safe, you're in a world of hurt. Your users start to see data that doesn't belong to them because the db just returns the first ID match it finds.</p>

<p>Alternatively, you've played it safe and you only let your database create ids. Writes only happen on a master database, and load is spread out over read replicas. But with this kind of strain, you have to start scaling your database writes horizontally, too, and suddenly your application starts to crawl (if the db is smart enough to guarantee unique ids between write hosts), or you start getting id collisions between different db hosts, so your write hosts don't agree about which ids represent which data.</p>

<h3>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Performance</h3>

<p>Because entities might need to be generated in high-performance loops, id generation should be fast. That means no waiting around for asynchronous entropy pool requests, or cross-process/cross-network communication. Performance slows to impracticality in the browser. All sources of entropy need to be fast enough for synchronous access.</p>

<p>Even worse, when the database is the only guarantee that ids are unique, that means that clients are forced to send incomplete records to the database, and wait for a network round-trip before they can use the ids in any algorithm. Forget about fast client performance. It simply isn't possible.</p>

<p>That situation has caused some clients to create ids that are only usable in a single client session (such as an in-memory counter). When the database returns the real id, the client has to do some juggling logic to swap out the id being used.</p>

<p>If client side ID generation were stronger, the chances of collision would be much smaller, and the client could send complete records to the db for insertion without waiting for a full round-trip request to finish before using the ID.</p>

<h4>
<a id="monotonically-increasing-ids" class="anchor" href="#monotonically-increasing-ids" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Monotonically increasing IDs</h4>

<p>Cuids generated by the same process are monotonically increasing, when less than 10000 cuids are generated within the same millisecond. Generated by different processes, the cuids will still have an increasing value in time if the process clocks are synchronized.</p>

<p>Monotonically increasing IDs are suitable for use as <a href="http://code.openark.org/blog/mysql/monotonic-functions-sql-and-mysql">high-performance database primary keys</a>, because they can be binary searched. Pure pseudo-random variants don't meet this requirement.</p>

<h4>
<a id="tiny" class="anchor" href="#tiny" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tiny</h4>

<p>Somewhat related to performance, an algorithm to generate an ID should require a tiny implementation. This is especially important for thick-client JavaScript applications.</p>

<h3>
<a id="security" class="anchor" href="#security" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Security</h3>

<p>Client-visible ids often need to have sufficient random data that it becomes practically impossible to try to guess valid IDs based on an existing, known id. That makes simple sequential ids unusable in the context of client-side generated database keys.</p>

<h4>
<a id="portability" class="anchor" href="#portability" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Portability</h4>

<p>Most stronger forms of the UUID / GUID algorithms require access to OS services that are not available in browsers, meaning that they are impossible to implement as specified.</p>

<h1>
<a id="features-of-cuids" class="anchor" href="#features-of-cuids" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features of cuids</h1>

<h2>
<a id="scalable" class="anchor" href="#scalable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scalable</h2>

<p>Because of the timestamp and the counter, cuid is really good at generating unique IDs on one machine.</p>

<p>Because of the fingerprints, cuid is also good at preventing collisions between multiple clients.</p>

<h2>
<a id="fast" class="anchor" href="#fast" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fast</h2>

<p>Because cuids can be safely generated synchronously, you can generate a lot of them quickly. Since it's unlikely that you'll get a collision, you don't have to wait for a round trip to the database just to insert a complete record in your database.</p>

<p>Because cuids are monotonically increasing, database primary key performance gets a significant boost.</p>

<p>Weighing in at less than 1k minified and compressed, the cuid source should be suitable for even the lightest-weight mobile clients, and will not have a significant impact on the download time of your app, particularly if you follow best practices and concatenate it with the rest of your code in order to avoid the latency hit of an extra file request.</p>

<h2>
<a id="secure" class="anchor" href="#secure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Secure</h2>

<p>Cuids contain enough random data and moving parts as to make guessing another id based on an existing id practically impossible. It also opens up a way to detect for abuse attempts -- if a client requests large blocks of ids that don't exist, there's a good chance that the client is malicious, or trying to get at data that doesn't belong to it.</p>

<h2>
<a id="portable" class="anchor" href="#portable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Portable</h2>

<p>The only part of a cuid that might be hard to replicate between different clients is the fingerprint. It's easy to override the fingerprint method in order to port to different clients. Cuid already works standalone in browsers, or as a node module, so you can use cuid where you need to use it.</p>

<p>The algorithm is also easy to reproduce in other languages. You are encouraged to port it to whatever language you see fit.</p>

<h3>
<a id="ports" class="anchor" href="#ports" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ports:</h3>

<ul>
<li>JavaScript (Browsers &amp; Node)</li>
<li>
<a href="https://github.com/iyshannon/cuid">cuid for Ruby</a> - <a href="https://github.com/iyshannon">Ian Shannon</a>
</li>
<li>
<a href="https://github.com/moonpyk/ncuid">cuid for .Net</a> - <a href="https://github.com/moonpyk">Clément Bourgeois</a>
</li>
<li>
<a href="http://github.com/lucsky/cuid">cuid for Go</a> - <a href="https://github.com/lucsky">Luc Heinrich</a>
</li>
<li>
<a href="https://github.com/endyjasmi/cuid">cuid for PHP</a> - <a href="https://github.com/endyjasmi">Endy Jasmi</a>
</li>
<li>
<a href="https://github.com/duailibe/cuid">cuid for Elixir</a> - <a href="https://github.com/duailibe">Lucas Duailibe</a>
</li>
<li>
<a href="https://github.com/eightyeight/hscuid">cuid for Haskell</a> - <a href="https://github.com/eightyeight">Daniel Buckmaster</a>
</li>
<li>
<a href="https://github.com/necaris/cuid.py">cuid for Python</a> - <a href="https://github.com/necaris">Rami Chowdhury</a>
</li>
<li>
<a href="https://github.com/hden/cuid">cuid for Clojure</a> - <a href="https://github.com/hden">Hao-kang Den</a>
</li>
<li>
<a href="https://github.com/graphcool/cuid-java">cuid for Java</a> - <a href="https://github.com/marktani">Nilan Marktanner</a>
</li>
</ul>

<h1>
<a id="short-urls" class="anchor" href="#short-urls" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Short URLs</h1>

<p>Need a smaller ID? <code>cuid.slug()</code> is for you. With fewer than 10 characters, <code>.slug()</code> is a great solution for short urls. Slugs may be 7 or more characters and grow as the internal counter increases. They're good for things like URL slug disambiguation (i.e., <code>example.com/some-post-title-&lt;slug&gt;</code>) but <strong>absolutely not recommended for database unique IDs</strong>. Stick to the full cuid for database keys.</p>

<p>Be aware, slugs:</p>

<ul>
<li><p>are less likely to be monotonically increasing. Stick to full cuids for database lookups, if possible.</p></li>
<li><p>have less random data, less room for the counter, and less room for the fingerprint, which means that all of them are more likely to collide or be guessed, especially as CPU speeds increase.</p></li>
</ul>

<p>Don't use them if guessing an existing ID would expose confidential information to malicious users. For example, if you're providing a service like Google Drive or DropBox, which hosts user's private files, favor <code>cuid()</code> over <code>.slug()</code>.</p>

<h1>
<a id="questions" class="anchor" href="#questions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions</h1>

<h3>
<a id="is-this-a-replacement-for-guid--uuid" class="anchor" href="#is-this-a-replacement-for-guid--uuid" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Is this a replacement for GUID / UUID?</h3>

<p>No. Cuid is great for the use case it was designed for -- to generate ids for applications which need to be scalable past tens or hundreds of new entities per second across multiple id-generating hosts. In other words, if you're building a web or mobile app and want the assurance that your choice of id standards isn't going to slow you down, cuid is for you.</p>

<p>However, if you need to obscure the order of id generation, or if it's potentially problematic to know the precise time that an id was generated, you'll want to go with something different.</p>

<p>Cuids should not be considered cryptographically secure (but neither should most guid algorithms. Make sure yours is using a crypto library before you rely on it).</p>

<h3>
<a id="why-dont-you-use-sha1-md5-etc" class="anchor" href="#why-dont-you-use-sha1-md5-etc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why don't you use sha1, md5, etc?</h3>

<p>A sha1 implementation in JavaScript is about 300 lines by itself, uncompressed, and its use would provide little benefit. For contrast, the cuid source code weighs in at less than 100 lines of code, uncompressed. It also comes at considerable performance cost. Md5 has similar issues.</p>

<h3>
<a id="why-are-there-no-dashes" class="anchor" href="#why-are-there-no-dashes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why are there no dashes?</h3>

<p>Almost all web-technology identifiers allow numbers and letters (though some require you to begin with a letter -- hence the 'c' at the beginning of a cuid). However, dashes are not allowed in some identifier names. Removing dashes between groups allows the ids to be more portable. Also, identifier groupings should not be relied on in your application. Removing them should discourage application developers from trying to extract data from a cuid.</p>

<p>The cuid specification should not be considered an API contract. Code that relies on the groupings as laid out here should be considered brittle and not be used in production.</p>

<h3>
<a id="submit-a-question-or-comment" class="anchor" href="#submit-a-question-or-comment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/dilvie/cuid/issues/new?title=Question">Submit a Question or Comment</a>
</h3>

<h3>
<a id="credit" class="anchor" href="#credit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credit</h3>

<p>Created by Eric Elliott, Author, <a href="http://ericleads.com/javascript-applications/">"Programming JavaScript Applications (O'Reilly)"</a></p>

<p>Thanks to <a href="http://tout.com/">Tout</a> for support and production testing.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cuid maintained by <a href="https://github.com/ericelliott">ericelliott</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-36908968-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
