<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Cuid : Collission-resistant ids optimized for horizontal scaling and performance." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Cuid</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/dilvie/cuid">View on GitHub</a>

          <h1 id="project_title">Cuid</h1>
          <h2 id="project_tagline">Collission-resistant ids optimized for horizontal scaling and performance.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/dilvie/cuid/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/dilvie/cuid/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>CUID</h1>

<p>Collission-resistant ids optimized for horizontal scaling and sequential lookup performance.</p>

<p>For node and browsers.</p>

<p>cuid() returns a short random string with some collision-busting measures. Safe to use as HTML element ID's, and unique server-side record lookups.</p>

<h2>Example</h2>

<p>ch72gsb320000udocl363eofy</p>

<h3>Broken down</h3>

<p>** c - h72gsb32 - 0000 - udoc - l363eofy **</p>

<p>The groups, in order, are:</p>

<ul>
<li>'c' - identifies this as a cuid, and allows you to use it in html entity ids. The fixed value helps keep the ids sequential.</li>
<li>Timestamp</li>
<li>Counter - a single process might generate the same random string. The weaker the pseudo-random source, the higher the probability. That problem gets worse as processors get faster. The counter will roll over if the value gets too big.</li>
<li>Client fingerprint</li>
<li>Pseudo random (<code>Math.random()</code> in JavaScript)</li>
</ul><h2>Fingerprints</h2>

<p><strong>In browsers</strong>, the first chars are obtained from the user agent string (which is fairly unique), and the supported mimeTypes (which is also fairly unique, except for IE, which always returns 0).
That string is concatenated with a count of variables in the global scope (which is also fairly unique), and the result is trimmed to 4 chars.</p>

<p><strong>In node</strong>, the first two chars are extracted from the process.pid. The next two chars are extracted from the hostname.</p>

<h2>Motivation</h2>

<p>Modern web applications have different requirements than applications from just a few years ago. Our modern unique identifiers have a stricter list of requirements that cannot all be satisfied by any existing version of the GUID/UUID specifications:</p>

<h3>Horizontal scalability</h3>

<p>Today's applications don't run on any single machine.</p>

<p>Applications might need to support online / offline capability, which means we need a way for clients on different hosts to generate ids that won't collide with ids generated by other hosts -- even if they're not connected to the network.</p>

<p>Most pseudo-random algorithms use time in ms as a random seed. Random IDs lack sufficient entropy when running in separate processes (such as cloned virtual machines or client browsers) to guarantee against collisions. Application developers report v4 UUID collisions causing problems in their applications when the ID generation is distributed between lots of machines such that lots of IDs are generated in the same millisecond.</p>

<p>Each new client exponentially increases the chance of collision in the same way that each new character in a random string exponentially reduces the chance of collision. Successful apps scale at hundreds or thousands of new clients per day, so fighting the lack of entropy by adding random characters is a losing strategy.</p>

<p>Because of the nature of this problem, it's possible to build an app from the ground up and scale it to a million users before this problem rears its head. By the time you notice the problem (when your peak hour use requires dozens of ids to be created per ms), if your db doesn't have unique constraints on the id because you thought your guids were safe, you're in a world of hurt. Your users start to see data that doesn't belong to them because the db just returns the first ID match it finds.</p>

<p>Alternatively, you've played it safe and you only let your database create ids. Writes only happen on a master database, and load is spread out over read replicas. But with this kind of strain, you have to start scaling your database writes horizontally, too, and suddenly your application starts to crawl (if the db is smart enough to guarantee unique ids between write hosts), or you start getting id collisions between different db hosts, so your write hosts don't agree about which ids represent which data.</p>

<h3>Performance</h3>

<p>Because entities might need to be generated in high-performance loops, id generation should be fast. That means no waiting around for asynchronous entropy pool requests, or cross-process/cross-network communication. Performance slows to impracticality in the browser. All sources of entropy need to be fast enough for synchronous access.</p>

<p>Even worse, when the database is the only guarantee that ids are unique, that means that clients are forced to send incomplete records to the database, and wait for a network round-trip before they can use the ids in any algorithm. Forget about fast client performance. It simply isn't possible.</p>

<p>That situation has caused some clients to create ids that are only usable in a single client session (such as an in-memory counter). When the database returns the real id, the client has to do some juggling logic to swap out the id being used.</p>

<p>If client side ID generation were stronger, the chances of collision would be much smaller, and the client could send complete records to the db for insertion without waiting for a full round-trip request to finish before using the ID.</p>

<h4>Sequential IDs</h4>

<p><a href="http://stackoverflow.com/questions/170346/what-are-the-performance-improvement-of-sequential-guid-over-standard-guid">Sequential ids can enhance performance</a> for database transactions for a variety of reasons. Ids should be suitable for use as high-performance database primary keys. Pure pseudo-random variants don't meet this requirement.</p>

<h4>Tiny</h4>

<p>Somewhat related to performance, an algorithm to generate an ID should require a tiny implementation. This is especially important for thick-client JavaScript applications.</p>

<h3>Security</h3>

<p>Client-visible ids often need to have sufficient random data that it becomes practically impossible to try to guess valid IDs based on an existing, known id. That makes simple sequential ids unusable in the context of client-side generated database keys.</p>

<h4>Portability</h4>

<p>Most stronger forms of the UUID / GUID algorithms require access to OS services that are not available in browsers, meaning that they are impossible to implement as specified.</p>

<h1>Features of cuids</h1>

<h2>Scaleable</h2>

<p>Because of the timestamp and the counter, cuid is really good at generating unique IDs on one machine.</p>

<p>Because of the fingerprints, cuid is also good at preventing collisions between multiple clients.</p>

<h2>Fast</h2>

<p>Because cuids can be safely generated synchronously, you can generate a lot of them quickly. Since it's unlikely that you'll get a collision, you don't have to wait for a round trip to the database just to insert a complete record in your database.</p>

<p>Because cuids are sequential, database primary key performance gets a significant boost.</p>

<p>Weighing in at less than 1k minified and compressed, the cuid source should be suitable for even the lightest-weight mobile clients, and will not have a significant impact on the download time of your app, particularly if you follow best practices and concatenate it with the rest of your code in order to avoid the latency hit of an extra file request.</p>

<h2>Secure</h2>

<p>Cuids contain enough random data and moving parts as to make guessing another id based on an existing id practically impossible. It also opens up a way to detect for abuse attempts -- if a client requests large blocks of ids that don't exist, there's a good chance that the client is malicious, or trying to get at data that doesn't belong to it.</p>

<h2>Portable</h2>

<p>The only part of a cuid that might be hard to replicate between different clients is the fingerprint. It's easy to override the fingerprint method in order to port to different clients. Cuid already works standalone in browsers, as a node module, or with applitude, so you can use cuid where you need to use it.</p>

<p>The algorithm is also easy to reproduce in other languages. You are encouraged to port it to whatever language you see fit.</p>

<h3>Ports:</h3>

<ul>
<li>JavaScript (Browsers, Browsers + <a href="https://github.com/dilvie/applitude">Applitude</a>, Node)</li>
<li>
<a href="https://github.com/iyshannon/cuid">CUID for Ruby</a> - <a href="https://github.com/iyshannon">Ian Shannon</a>
</li>
</ul><h1>Questions</h1>

<h3>Is this a replacement for GUID / UUID?</h3>

<p>No. Cuid is great for the use case it was designed for -- to generate ids for applications which need to be scaleable past tens or hundreds of new entities per second across multiple id-generating hosts. In other words, if you're building a web or mobile app and want the assurance that your choice of id standards isn't going to slow you down, cuid is for you.</p>

<p>However, if you need to obscure the order of id generation, or if it's potentially problematic to know the precise time that an id was generated, you'll want to go with something different.</p>

<p>Cuids should not be considered cryptographically secure (but neither should most guid algorithms. Make sure yours is using a crypto library before you rely on it).</p>

<h3>Why don't you use sha1, md5, etc?</h3>

<p>A sha1 implementation in JavaScript is about 300 lines by itself, uncompressed, and its use would provide little benefit. For contrast, the cuid source code weighs in at less than 100 lines of code, uncompressed. It also comes at considerable performance cost. Md5 has similar issues.</p>

<h3>Why are there no dashes?</h3>

<p>Almost all web-technology identifiers allow numbers and letters (though some require you to begin with a letter -- hence the 'c' at the beginning of a cuid). However, dashes are not allowed in some identifier names. Removing dashes between groups allows the ids to be more portable. Also, identifier groupings should not be relied on in your application. Removing them should discourage application developers from trying to extract data from a cuid.</p>

<p>The cuid specification should not be considered an API contract. Code that relies on the groupings as laid out here should be considered brittle and not be used in production.</p>

<h3><a href="https://github.com/dilvie/cuid/issues/new?title=Question">Submit a Question or Comment</a></h3>

<h3>Credit</h3>

<p>Created by Eric Elliott, Author, <a href="http://shop.oreilly.com/product/0636920024231.do">"Programming JavaScript Applications (O'Reilly)"</a></p>

<p>Thanks to <a href="http://tout.com/">Tout</a> for support and production testing.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cuid maintained by <a href="https://github.com/dilvie">dilvie</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-36908968-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
